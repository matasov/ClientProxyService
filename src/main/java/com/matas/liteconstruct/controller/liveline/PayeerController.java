package com.matas.liteconstruct.controller.liveline;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.apache.commons.codec.digest.DigestUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.util.Base64Utils;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import com.matas.liteconstruct.db.DBConstants;
import com.matas.liteconstruct.db.models.serviceauthorized.model.AuthorozedContact.MapKey;
import com.matas.liteconstruct.db.models.serviceauthorized.repos.AuthorizedContactRepository;
import com.matas.liteconstruct.db.models.streamfiltersgroup.factorygroup.FactoryGroupAbstract;
import com.matas.liteconstruct.service.SQLProtection;
import com.matas.liteconstruct.service.business.LiveLineBusinessService;
import com.matas.liteconstruct.service.business.LiveLineQueuePoolExecutor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Controller
@RequestMapping("/payeer")
public class PayeerController {

  @Value("${payeer.password}")
  private String payeerPassword;

  private LiveLineQueuePoolExecutor liveLineQueuePoolExecutor;

  @Autowired
  public void setLiveLineQueuePoolExecutor(LiveLineQueuePoolExecutor liveLineQueuePoolExecutor) {
    this.liveLineQueuePoolExecutor = liveLineQueuePoolExecutor;
  }

  private AuthorizedContactRepository authorizedContactRepository;

  @Autowired
  public void setAuthorozedContactRepository(
      AuthorizedContactRepository authorozedContactRepository) {
    this.authorizedContactRepository = authorozedContactRepository;
  }

  private LiveLineBusinessService liveLineBusinessService;

  @Autowired
  public void setLiveLineBusinessService(LiveLineBusinessService liveLineBusinessService) {
    this.liveLineBusinessService = liveLineBusinessService;
  }

  @RequestMapping(value = "/payment", method = RequestMethod.GET)
  public ResponseEntity<?> request() {
    return new ResponseEntity<>("<!DOCTYPE html>\r\n" + "<html>\r\n" + "<head>\r\n"
        + "<!-- HTML meta URL redirect - generated by www.rapidtables.com -->\r\n"
        + "<meta http-equiv=\"refresh\" content=\"0; url=http://live-line.biz/payment?result=Record is present yet!\">\r\n"
        + "</head>\r\n" + "<body>\r\n" + "</body>\r\n" + "</html>", HttpStatus.OK);
  }

  @RequestMapping(value = "/key", method = RequestMethod.POST)
  public ResponseEntity<?> getKey(@RequestParam("m_shop") String mShop,
      @RequestParam("m_orderid") String mOrderId, @RequestParam("m_amount") String mAmount,
      @RequestParam("m_curr") String mCurr, @RequestParam("m_desc") String mDesc) {
    String sha256hex = DigestUtils.sha256Hex(new StringBuilder().append(mShop).append(":")
        .append(mOrderId).append(":").append(mAmount).append(":").append(mCurr).append(":")
        .append(mDesc).append(":").append(payeerPassword).toString());

    return new ResponseEntity<>("{\"key\":\"" + sha256hex.toUpperCase() + "\"}", HttpStatus.OK);
  }

  @RequestMapping(value = "/payment", method = RequestMethod.POST)
  public ResponseEntity<?> setPayment(HttpEntity<String> httpEntity
  // @RequestParam("m_operation_id") String operationId,
  // @RequestParam("m_shop") String shopId, @RequestParam("m_amount") String amount,
  // @RequestParam("m_orderid") String orderId, @RequestParam("m_curr") String currency,
  // @RequestParam("m_desc") String description, @RequestParam("m_operation_ps") String operation,
  // @RequestParam("m_sign") String sign, @RequestParam("m_operation_date") String operationDate,
  // @RequestParam("m_operation_pay_date") String payOperationDate,
  // @RequestParam("m_status") String status
  ) {
    String redirectUrl = "http://live-line.biz";
    Map<String, String> queryParams = null;
    String errorMessage = null;
    double paymentAmount;
    String userName;
    try {
      log.info("total incoming string: {}", httpEntity.getBody());
      String workString =
          URLDecoder.decode(httpEntity.getBody(), StandardCharsets.UTF_8.toString());
      log.info("payeer receive string: {}", workString);
      queryParams = Stream.of((String[]) workString.split("&"))
          .collect(Collectors.toMap(x -> ((String) x).substring(0, ((String) x).indexOf("=")),
              x -> ((String) x).substring(((String) x).indexOf("=") + 1, ((String) x).length())));
      userName = ((String) SQLProtection
          .protectRequestObject(new String(Base64Utils.decodeFromString(queryParams.get("m_desc")))))
              .toLowerCase();
    } catch (NullPointerException | UnsupportedEncodingException ex) {
      ex.printStackTrace();
      log.error("not found correct post body in payeer request. {}", ex.getMessage());
      errorMessage = ex.getLocalizedMessage();
      userName = null;
    }
    if (errorMessage == null) {
      Map<String, Object> localAccessPermissions = null;
      try {
        localAccessPermissions = (Map<String, Object>) authorizedContactRepository
            .getAuthorizedContactByName(userName).getPermissions().get(MapKey.PERMISSIONS);
        paymentAmount = Double.parseDouble(queryParams.get("m_amount"));
      } catch (Exception ex) {
        errorMessage = "Not found values for user: " + userName;
        return new ResponseEntity<>(
            "<!DOCTYPE html>\r\n" + "<html>\r\n" + "<head>\r\n"
                + "<meta http-equiv=\"refresh\" content=\"0; url=" + redirectUrl
                + "/payment?result=notfound\">\r\n"

                + "</head>\r\n" + "<body>\r\n" + "</body>\r\n" + "</html>",
            HttpStatus.EXPECTATION_FAILED);
      }

      String sha256hex = null;
      if (errorMessage == null)
        sha256hex = DigestUtils.sha256Hex(new StringBuilder()
            .append(queryParams.get("m_operation_id")).append(":")
            .append(queryParams.get("m_operation_ps")).append(":")
            .append(queryParams.get("m_operation_date")).append(":")
            .append(queryParams.get("m_operation_pay_date")).append(":")
            .append(queryParams.get("m_shop")).append(":").append(queryParams.get("m_orderid"))
            .append(":").append(queryParams.get("m_amount")).append(":")
            .append(queryParams.get("m_curr")).append(":").append(queryParams.get("m_desc"))
            .append(":").append(queryParams.get("m_status"))

            .append(queryParams.containsKey("m_params") ? ":" + queryParams.get("m_params") : "")
            .append(":").append(payeerPassword).toString()).toUpperCase();
      if (sha256hex != null && sha256hex.equals(queryParams.get("m_sign"))) {
        // start payment
        Date operationDate;
        try {
          operationDate = new SimpleDateFormat("dd.MM.yyyy HH:mm:ss")
              .parse(queryParams.get("m_operation_pay_date"));
        } catch (ParseException e) {
          e.printStackTrace();
          operationDate = null;
        }
        long timeStamp = operationDate == null ? -1 : operationDate.getTime();
//        if (timeStamp > 10000000000000l) {
//          timeStamp = timeStamp / 1000;
//        }
        if (errorMessage == null)
          errorMessage = liveLineBusinessService.paymentCredit(userName,
              UUID.fromString((String) localAccessPermissions
                  .get(FactoryGroupAbstract.getFirstPartOfUUID(DBConstants.CONTACT_ID))),
              paymentAmount, UUID.fromString("fb2a7511-99e4-4418-8e18-18deb93f5e72"), false, 0,
              Long.toString(timeStamp), "payment", userName.toLowerCase(),
              "3ca41c65-0d98-415b-9cfa-cdbc86d223bb");
      } else {
        errorMessage = "Hash is not equal. ";
      }
    }
    HttpStatus resultStatus;
    if (errorMessage == null) {
      errorMessage = "success";
      resultStatus = HttpStatus.OK;
      liveLineQueuePoolExecutor.addNewQuery();
    } else {
      resultStatus = HttpStatus.FAILED_DEPENDENCY;
    }
    return new ResponseEntity<>(
        "<!DOCTYPE html>\r\n" + "<html>\r\n" + "<head>\r\n"
            + "<!-- HTML meta URL redirect - generated by www.rapidtables.com -->\r\n"
            + "<meta http-equiv=\"refresh\" content=\"0; url=" + redirectUrl + "/payment?result="
            + errorMessage + "\">\r\n" + "</head>\r\n" + "<body>\r\n" + "</body>\r\n" + "</html>",
        resultStatus);
  }

  public boolean checkHash(String toHash, String compaireValue) {
    String md5Hex = DigestUtils.md5Hex(toHash).toUpperCase();

    return md5Hex.equals(compaireValue);
  }


}
